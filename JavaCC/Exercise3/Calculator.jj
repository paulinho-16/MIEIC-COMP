/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. .\Calculator.jj */
/*@egen*/options
{
    LOOKAHEAD=2;
}

PARSER_BEGIN(Calculator)

import java.util.Map;
import java.util.HashMap;

public class Calculator/*@bgen(jjtree)*/implements CalculatorTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected static JJTCalculatorState jjtree = new JJTCalculatorState();

/*@egen*/
    final Map<String, Integer> assignments = new HashMap();

    public static void main(String args[]) throws ParseException {
        System.out.println("Parser for a calculator that accepts expressions with integers, +,-,*,/,(,) and =.");
        System.out.println("Write an arithmetic expression or assignments followed by an expression:");
        Calculator myCalc = new Calculator(System.in);
        SimpleNode root = myCalc.Expression(); // returns reference to root node

        root.dump(""); // prints the tree on the screen

        System.out.println("\nExpression value: " + myCalc.traverse(root));
    }

    int traverse(SimpleNode node) {
        for(int i = 0; i < node.jjtGetNumChildren() - 1; i++){
            eval((SimpleNode) node.jjtGetChild(i));
        }
        return eval((SimpleNode) node.jjtGetChild(node.jjtGetNumChildren() - 1));
    }

    int eval(SimpleNode node) {
        if(node.jjtGetNumChildren() == 0) // leaf node with integer value or symbol
            return node.id != CalculatorTreeConstants.JJTRETRIEVE ? node.val : node.sign * assignments.get(node.var);
        else if(node.jjtGetNumChildren() == 1) { // only one child
            if (node.id == CalculatorTreeConstants.JJTASSIGN) {
                assignments.put(node.var, eval((SimpleNode) node.jjtGetChild(0)));
                return 0;
            }
            return this.eval((SimpleNode) node.jjtGetChild(0));
        }

        SimpleNode lhs = (SimpleNode) node.jjtGetChild(0); //left child
        SimpleNode rhs = (SimpleNode) node.jjtGetChild(1); // right child

        switch(node.id) {
             case CalculatorTreeConstants.JJTADD : return eval( lhs ) + eval( rhs );
             case CalculatorTreeConstants.JJTSUB : return eval( lhs ) - eval( rhs );
             case CalculatorTreeConstants.JJTMUL : return eval( lhs ) * eval( rhs );
             case CalculatorTreeConstants.JJTDIV : return eval( lhs ) / eval( rhs );
             default : // abort
                System.out.println("Illegal operator!");
                System.exit(1);
        }
        return 0;
    }
}

PARSER_END(Calculator)

SKIP :
{
    " " | "\r" | "\t"
}

TOKEN:
{
    < INTEGER: (["0"-"9"])+ >
    | < LF: "\n" >
    | <SYMBOL: ["A"-"Z", "a"-"z"](["A"-"Z", "a"-"z", "0"-"9"])*>
    | < SEMICOL: ";" >
    | < EQ: "=" >
}

SimpleNode Expression(): {/*@bgen(jjtree) Expression */
  SimpleNode jjtn000 = new SimpleNode(JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Expression */
    try {
/*@egen*/
    Expr0() <LF>/*@bgen(jjtree)*/
                 {
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                 }
/*@egen*/ {return jjtn000;}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/ // Java code inside brackets
}

void Expr0()      : {Token t;}
{
    (/*@bgen(jjtree) #Assign( 1) */
        {
          SimpleNode jjtn001 = new SimpleNode(JJTASSIGN);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
        (t = <SYMBOL> { jjtn001.var = t.image; } <EQ> Expr1(1))/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  1);
          }
        }
/*@egen*/           
        <SEMICOL> <LF>
    )*
    Expr1(1) <SEMICOL>
}

void Expr1(int sign)      : {}
{
    Expr2(sign)
    (
        ( "+"/*@bgen(jjtree) #Add( 2) */
              {
                SimpleNode jjtn001 = new SimpleNode(JJTADD);
                boolean jjtc001 = true;
                jjtree.openNodeScope(jjtn001);
              }
              try {
/*@egen*/ Expr2(sign)/*@bgen(jjtree)*/
              } catch (Throwable jjte001) {
                if (jjtc001) {
                  jjtree.clearNodeScope(jjtn001);
                  jjtc001 = false;
                } else {
                  jjtree.popNode();
                }
                if (jjte001 instanceof RuntimeException) {
                  throw (RuntimeException)jjte001;
                }
                if (jjte001 instanceof ParseException) {
                  throw (ParseException)jjte001;
                }
                throw (Error)jjte001;
              } finally {
                if (jjtc001) {
                  jjtree.closeNodeScope(jjtn001,  2);
                }
              }
/*@egen*/        
        | "-"/*@bgen(jjtree) #Sub( 2) */
              {
                SimpleNode jjtn002 = new SimpleNode(JJTSUB);
                boolean jjtc002 = true;
                jjtree.openNodeScope(jjtn002);
              }
              try {
/*@egen*/ Expr2(sign)/*@bgen(jjtree)*/
              } catch (Throwable jjte002) {
                if (jjtc002) {
                  jjtree.clearNodeScope(jjtn002);
                  jjtc002 = false;
                } else {
                  jjtree.popNode();
                }
                if (jjte002 instanceof RuntimeException) {
                  throw (RuntimeException)jjte002;
                }
                if (jjte002 instanceof ParseException) {
                  throw (ParseException)jjte002;
                }
                throw (Error)jjte002;
              } finally {
                if (jjtc002) {
                  jjtree.closeNodeScope(jjtn002,  2);
                }
              }
/*@egen*/        )
    )*
}

void Expr2(int sign)      : {}  // 1: positive; -1: negative, because of the \u00e2\u20ac\u02dc-\u00e2\u20ac\u02dc unitary operator
{
    Expr3(sign)
    ( "*"/*@bgen(jjtree) #Mul( 2) */
          {
            SimpleNode jjtn001 = new SimpleNode(JJTMUL);
            boolean jjtc001 = true;
            jjtree.openNodeScope(jjtn001);
          }
          try {
/*@egen*/ Expr3(sign)/*@bgen(jjtree)*/
          } catch (Throwable jjte001) {
            if (jjtc001) {
              jjtree.clearNodeScope(jjtn001);
              jjtc001 = false;
            } else {
              jjtree.popNode();
            }
            if (jjte001 instanceof RuntimeException) {
              throw (RuntimeException)jjte001;
            }
            if (jjte001 instanceof ParseException) {
              throw (ParseException)jjte001;
            }
            throw (Error)jjte001;
          } finally {
            if (jjtc001) {
              jjtree.closeNodeScope(jjtn001,  2);
            }
          }
/*@egen*/        
    | "/"/*@bgen(jjtree) #Div( 2) */
          {
            SimpleNode jjtn002 = new SimpleNode(JJTDIV);
            boolean jjtc002 = true;
            jjtree.openNodeScope(jjtn002);
          }
          try {
/*@egen*/ Expr3(sign)/*@bgen(jjtree)*/
          } catch (Throwable jjte002) {
            if (jjtc002) {
              jjtree.clearNodeScope(jjtn002);
              jjtc002 = false;
            } else {
              jjtree.popNode();
            }
            if (jjte002 instanceof RuntimeException) {
              throw (RuntimeException)jjte002;
            }
            if (jjte002 instanceof ParseException) {
              throw (ParseException)jjte002;
            }
            throw (Error)jjte002;
          } finally {
            if (jjtc002) {
              jjtree.closeNodeScope(jjtn002,  2);
            }
          }
/*@egen*/        
    )*
}

void Expr3(int sign)      : {Token t;}
{
    t = <INTEGER>/*@bgen(jjtree) Term */
                  {
                    SimpleNode jjtn001 = new SimpleNode(JJTTERM);
                    boolean jjtc001 = true;
                    jjtree.openNodeScope(jjtn001);
                  }
                  try {
/*@egen*//*@bgen(jjtree)*/
                  {
                    jjtree.closeNodeScope(jjtn001, true);
                    jjtc001 = false;
                  }
/*@egen*/ { jjtn001.val = sign * Integer.parseInt(t.image); jjtn001.sign = sign; }/*@bgen(jjtree)*/
                  } finally {
                    if (jjtc001) {
                      jjtree.closeNodeScope(jjtn001, true);
                    }
                  }
/*@egen*/      
    | t = <SYMBOL>/*@bgen(jjtree) Retrieve */
                   {
                     SimpleNode jjtn002 = new SimpleNode(JJTRETRIEVE);
                     boolean jjtc002 = true;
                     jjtree.openNodeScope(jjtn002);
                   }
                   try {
/*@egen*//*@bgen(jjtree)*/
                   {
                     jjtree.closeNodeScope(jjtn002, true);
                     jjtc002 = false;
                   }
/*@egen*/ { jjtn002.var = t.image; jjtn002.sign = sign; }/*@bgen(jjtree)*/
                   } finally {
                     if (jjtc002) {
                       jjtree.closeNodeScope(jjtn002, true);
                     }
                   }
/*@egen*/          
    | "(" Expr1(sign) ")"
    | "-"/*@bgen(jjtree) Minus */
          {
            SimpleNode jjtn003 = new SimpleNode(JJTMINUS);
            boolean jjtc003 = true;
            jjtree.openNodeScope(jjtn003);
          }
          try {
/*@egen*/ Expr3(sign == 1 ? -1 : 1)/*@bgen(jjtree)*/
          } catch (Throwable jjte003) {
            if (jjtc003) {
              jjtree.clearNodeScope(jjtn003);
              jjtc003 = false;
            } else {
              jjtree.popNode();
            }
            if (jjte003 instanceof RuntimeException) {
              throw (RuntimeException)jjte003;
            }
            if (jjte003 instanceof ParseException) {
              throw (ParseException)jjte003;
            }
            throw (Error)jjte003;
          } finally {
            if (jjtc003) {
              jjtree.closeNodeScope(jjtn003, true);
            }
          }
/*@egen*/       
}